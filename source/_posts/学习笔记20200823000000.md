---
title: 学习笔记20200823000000
date: 2020-08-23 23:27:00
categories: 学习笔记
tags: []
copyright: true #新增,开启
---

#### 关于分库分表的一些学习

之前有说到过分库分表这个问题,但是分库分表以后会面临几个问题
+ 分表一般是按某个字段当关键词进行分表,但这也就造成了,如果where的一个目标是非关键词,我们就无法知道他属于哪张表
+ limit,order by,group by无法做到全局视角

那么接下来说一下我学到的一些方法
+ 对于where这种情况,可以选择
  + 建立映射表,将id和要where的字段单独拿张表映射,并且做到缓存里面(当然,无法避免有些情况下缓存来不及同步,这种我只能想到去所有库查询)
  + 做冗余字段,所有表都围绕关键词做冗余,一律拿关键词去查询
+ limit和order by目前只知道在偏移量小的情况下,可以取各库偏移量之前的全部数据,内存中比较,其他方法目前未知,待补充

还有一点,对于分库分表的情况来说,应当尽量在需求阶段进行回绝,或者说严格限制搜索条件,例如我where一个关键字段和两个字段,在业务层聚合排序时操作的数据量必定不是一个量级,这时候就可以用取各表前n个字段再聚合的方式进行分页查询。我们也可以限制查询时间,只查询最近几个月。还有种方式可能就是跳出关系型数据库,利用大数据平台来进行查询,这个的具体操作目前还没想明白

#### 关于秒杀的一些学习

秒杀系统主要是面对的短时间(秒/分钟级别)的瞬间流量激增,如果说堆机器的话,过于浪费(因为只用那几分钟)。

对于这种情况,可以从以下几点来思考
+ 缓存:包括前端缓存,cdn分流静态资源,后端热点数据缓存,需要秒杀的商品及数量做缓存
+ 限流:对于秒杀场景,其实真正能抢到货的人较少,所以对于进入慢的请求是没有意义的(这里要注意用户体验,不能以错误的形式呈现,而是货物已被锁定或其他话语)。对于没有被拦截下来的请求,可以直接走缓存(这里缓存要做持久化)判断是否还有库存(锁单),对于没有库存的情况下,可以允许用户等待(因为前面有可能有人放弃订单,这时候库存就放出来了,此时给用户呈现的可以是库存已无,正在尝试等待其他用户取消订单)
+ 队列:如果被迫接受命令进行处理,容易压爆服务器,可以选择解耦,用户请求扔到队列,服务器主动去请求(可以为秒杀进行单独设计),这里需要做好前端交互和呈现,避免用户以为网络卡住
+ 降级:暂时关闭/延迟/异步执行非核心部分,将资源挪给核心
+ 主备:秒杀场景对于时效性有很高要求,要预防宕机
+ 持久化:如果宕机,这里要考虑时间(如果出现意外,应该放弃过旧的数据),例如用户秒杀了,但是宕机卡住了,并且他以为自己没买上又抢了其他商品,这时候突然系统恢复数据,买上了,对于用户来说是重复购买(或者跟前端做好交互,防止用户误会)
+ 独立部署:秒杀独立出来成为一个单独的系统

这里对于一些常规的分布式手段例如,堆机器,分库分表就没有提及,主要是思想。其实个人感觉目前看过的这几个架构,变来变去基本内容也无非是缓存,限流,队列,降级这一套。关键是与业务结合起来灵活变通和组合,并且配合一些补偿/预防机制(压测,监控,开关,第二套备用方案)
