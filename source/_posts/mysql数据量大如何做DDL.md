---
title: mysql数据量大如何做DDL
date: 2021-08-27 00:03:00
categories: mysql
tags: [mysql]
copyright: true #新增,开启
---

# 一、背景
mysql单表数据量小，并发压力小时，我们可以考虑直接在表上做alter操作。  
一旦数据量达到百万千万级别，直接alter会导致长时间缩表，此时我们就无法无脑alter。  
这章与大家聊一聊，mysql表中数据量大时，如何做DDL操作。
<!--more-->

# 二、正文
目前常用的两种方式gh-ost, pt-osc。这两种方式的目的均是为了尽最大可能保证DDL时不影响整体业务正常进行，而并非全程不锁定数据

## gh-ost
这里我们假设要对表a增加一列
操作步骤：
```
1、创建与表a结构当前结构一致的空表，叫做a.tmp
2、对a.tmp执行alter语句，增加列
3、增量同步：消费binlog，将a表binlog应用到a.tmp表（insert操作替换为replace覆盖）
4、存量同步：//注意，步骤3与步骤4可并行执行
- 查询现有表id
- 将id分批，每n个一批，加写锁 //写锁为排他锁，可禁止select后，插入a.tmp前产生该行新binlog
- 将该批数据select后应用到a.tmp表（操作为replace覆盖）
- 应用后该批数据解锁
- 下一批数据重复该操作
5、当存量同步完成，锁表，等binlog追平
6、将表a与a.tmp交换表名，
7、流程结束
```
里面其实简化了很多东西，与gh-ost有些许出入，不过确可以帮助我们更快速理解gh-ost玩法

这里解释几个原理：  

1、步骤3与步骤4为何可以并行？
- 首先我们所有的操作均为覆盖含义（insert已替换为覆盖，update实际上解析binlog得到的是数据更改后的绝对量，而非i=i+1这种相对量）
- 我们select时对数据加了写锁（排他锁），在insert成功前数据不会被修改，不会产生binlog
- 若select先执行，binlog后执行。由于数据覆盖，当binlog追平后数据必然最新
- 若binlog先执行，select后执行。由于select加写锁，select后插入的必为最新数据
- 总的来说，对于某行数据，两种操作无论中途并行穿插多少次，最后一次执行的操作总能保证该行数据最新

2、这种方式如何保证业务正常进行？
- 由于我们是分批加锁，仅涉及该批数据用户被阻塞，瞬时不可用。其他用户依然可正常读写

3、该方式有什么限制？
- 由于依赖主键进行select，必须要求具备主键
- 建议mysql 5.7及以上

4、第六步交换表名如何操作？
- 交换表名时借助第三张表，过程如下
```
1、A线程：创建_del表，对源表和_del表加写锁
2、B线程：执行rename table `源表` to `del表`, `临时表` to `源表`。 此时由于A线程的锁，B线程操作被阻塞
3、检查是否有待执行renmae请求
4、A线程：先执行删除_del表命令，再释放锁 

//原理
//考虑到A线程可能由于断开会话，导致锁释放，新数据汇入源表。所以提前创建_del表占位，使得rename执行前感知到锁
//由于在mysql中，多个语句被block时，rename优先级最高，故rename会先被执行
//删除_del时，由于我们采用lock方式缩表，会直接释放_del的锁，而依旧源表的锁
```

缺点：  
1、mysql5.6及以下，不支持并行复制，效率低  
2、gh-ost高负载下由于顺序消费binlog，性能会低于pt-osc

## pt-osc
基本原理与gh-ost一致

不同之处在于，pt-osc不采用binlog，而是采用mysql触发器同步增量数据。具体消费方式与gh-ost基本一致。

缺点：  
1、触发器并行执行，对mysql压力大

## mysql原生Online DDL
未研究，据有限资料，各方面要好于gh-ost,pt-osc,但也有一定局限性

# 三、扩展
当下游数仓需要捞取binlog同步数据时，如何使下游对pt-osc,gh-ost无感知？
答：可借鉴DM工具的方式，将涉及pt-osc,gh-ost特有名称后缀的DML语句，缓存起来。后续数据继续解析，直到接收rename语句，再将缓存的DML语句改写后发送至下游。  
具体需考虑有业务场景及上游操作方式，如上游保证全部分表rename后才会写入新数据，则我们便可在收到第一条DDL 语句后继续消费DML。  
若上游保证全部分表格式相同，则我们可以接到第一条DDL即应用到下游