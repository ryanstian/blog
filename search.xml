<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql数据量大如何做DDL</title>
    <url>/2021/08/27/mysql%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%A7%E5%A6%82%E4%BD%95%E5%81%9ADDL/</url>
    <content><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>mysql单表数据量小，并发压力小时，我们可以考虑直接在表上做alter操作。<br>一旦数据量达到百万千万级别，直接alter会导致长时间缩表，此时我们就无法无脑alter。<br>这章与大家聊一聊，mysql表中数据量大时，如何做DDL操作。</p>
<a id="more"></a>

<h1 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h1><p>目前常用的两种方式gh-ost, pt-osc。这两种方式的目的均是为了尽最大可能保证DDL时不影响整体业务正常进行，而并非全程不锁定数据</p>
<h2 id="gh-ost"><a href="#gh-ost" class="headerlink" title="gh-ost"></a>gh-ost</h2><p>这里我们假设要对表a增加一列<br>操作步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、创建与表a结构当前结构一致的空表，叫做a.tmp</span><br><span class="line">2、对a.tmp执行alter语句，增加列</span><br><span class="line">3、增量同步：消费binlog，将a表binlog应用到a.tmp表（insert操作替换为replace覆盖）</span><br><span class="line">4、存量同步：//注意，步骤3与步骤4可并行执行</span><br><span class="line">- 查询现有表id</span><br><span class="line">- 将id分批，每n个一批，加写锁 //写锁为排他锁，可禁止select后，插入a.tmp前产生该行新binlog</span><br><span class="line">- 将该批数据select后应用到a.tmp表（操作为replace覆盖）</span><br><span class="line">- 应用后该批数据解锁</span><br><span class="line">- 下一批数据重复该操作</span><br><span class="line">5、当存量同步完成，锁表，等binlog追平</span><br><span class="line">6、将表a与a.tmp交换表名，</span><br><span class="line">7、流程结束</span><br></pre></td></tr></table></figure>

<p>里面其实简化了很多东西，与gh-ost有些许出入，不过确可以帮助我们更快速理解gh-ost玩法</p>
<p>这里解释几个原理：  </p>
<p>1、步骤3与步骤4为何可以并行？</p>
<ul>
<li>首先我们所有的操作均为覆盖含义（insert已替换为覆盖，update实际上解析binlog得到的是数据更改后的绝对量，而非i=i+1这种相对量）</li>
<li>我们select时对数据加了写锁（排他锁），在insert成功前数据不会被修改，不会产生binlog</li>
<li>若select先执行，binlog后执行。由于数据覆盖，当binlog追平后数据必然最新</li>
<li>若binlog先执行，select后执行。由于select加写锁，select后插入的必为最新数据</li>
<li>总的来说，对于某行数据，两种操作无论中途并行穿插多少次，最后一次执行的操作总能保证该行数据最新</li>
</ul>
<p>2、这种方式如何保证业务正常进行？</p>
<ul>
<li>由于我们是分批加锁，仅涉及该批数据用户被阻塞，瞬时不可用。其他用户依然可正常读写</li>
</ul>
<p>3、该方式有什么限制？</p>
<ul>
<li>由于依赖主键进行select，必须要求具备主键</li>
<li>建议mysql 5.7及以上</li>
</ul>
<p>4、第六步交换表名如何操作？</p>
<ul>
<li>交换表名时借助第三张表，过程如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、A线程：创建_del表，对源表和_del表加写锁</span><br><span class="line">2、B线程：执行rename table `源表` to `del表`, `临时表` to `源表`。 此时由于A线程的锁，B线程操作被阻塞</span><br><span class="line">3、检查是否有待执行renmae请求</span><br><span class="line">4、A线程：先执行删除_del表命令，再释放锁 </span><br><span class="line"></span><br><span class="line">//原理</span><br><span class="line">//考虑到A线程可能由于断开会话，导致锁释放，新数据汇入源表。所以提前创建_del表占位，使得rename执行前感知到锁</span><br><span class="line">//由于在mysql中，多个语句被block时，rename优先级最高，故rename会先被执行</span><br><span class="line">//删除_del时，由于我们采用lock方式缩表，会直接释放_del的锁，而依旧源表的锁</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>缺点：<br>1、mysql5.6及以下，不支持并行复制，效率低<br>2、gh-ost高负载下由于顺序消费binlog，性能会低于pt-osc</p>
<h2 id="pt-osc"><a href="#pt-osc" class="headerlink" title="pt-osc"></a>pt-osc</h2><p>基本原理与gh-ost一致</p>
<p>不同之处在于，pt-osc不采用binlog，而是采用mysql触发器同步增量数据。具体消费方式与gh-ost基本一致。</p>
<p>缺点：<br>1、触发器并行执行，对mysql压力大</p>
<h2 id="mysql原生Online-DDL"><a href="#mysql原生Online-DDL" class="headerlink" title="mysql原生Online DDL"></a>mysql原生Online DDL</h2><p>未研究，据有限资料，各方面要好于gh-ost,pt-osc,但也有一定局限性</p>
<h1 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h1><p>当下游数仓需要捞取binlog同步数据时，如何使下游对pt-osc,gh-ost无感知？<br>答：可借鉴DM工具的方式，将涉及pt-osc,gh-ost特有名称后缀的DML语句，缓存起来。后续数据继续解析，直到接收rename语句，再将缓存的DML语句改写后发送至下游。<br>具体需考虑有业务场景及上游操作方式，如上游保证全部分表rename后才会写入新数据，则我们便可在收到第一条DDL 语句后继续消费DML。<br>若上游保证全部分表格式相同，则我们可以接到第一条DDL即应用到下游</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat源码笔记</title>
    <url>/2019/08/14/Tomcat%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本章我们不会涉及代码,而是简要的介绍Tomcat的实现原理</p>
<a id="more"></a>
<p><strong>Tomcat版本9.0.21</strong></p>
<h2 id="Tomcat是什么"><a href="#Tomcat是什么" class="headerlink" title="Tomcat是什么?"></a>Tomcat是什么?</h2><p>在我看来,Tomcat是利用各种模型和设计方式对socket的深度封装,做到适配各种协议同时达到一定性能的代码组<br>同时给我们写的各种业务代码(Servlet)提供了容器(也可以理解为tomcat可以将以对象的形式使用我们写的Servlet业务),这是Tomcat的核心。<br>当然,Tomcat还实现了一些其他的比如生命周期管理,但是这些都是为了核心而服务的</p>
<p>我们第一次接触Tomcat,相信大多数人都是Hello World。<br>想想当时我们是怎么做的:</p>
<ul>
<li>我们建立了个项目</li>
<li>按照网上的教程建好了项目里面的文件夹</li>
<li>导入servlet包</li>
<li>开始编写xml配置文件</li>
<li>继承Servlet编写Get,Post代码</li>
<li>导出war包放到tomcat下的webapps文件夹</li>
<li>启动tomcat</li>
</ul>
<p>so easy,然后我们就可以通过浏览器访问我们之前写好的接口了。</p>
<p>但是,我们有没有想过是为什么,为什么我们GET中的代码会被调用,为什么我们访问一个网址会执行我们的代码,他又是怎么执行的？</p>
<p>这一切,我们将从Tomcat中找到答案</p>
<h2 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h2><p>首先,消息是如何接收的？</p>
<p>这里,我要阐述下自己的理解：  </p>
<ul>
<li>在网络传输的世界里面,一切都是消息。<br>消息是指什么?<br>消息可以理解为一串二进制,一串byte或者字符串（当然,在网络模型的最底层,这些都会被转换为二进制来传输）</li>
<li>协议又是什么?<br>协议是一种事先约定的规范。规定了消息格式,消息处理方式等等各种机制<br>例如，我们编写servlet最常用到的http协议,他的可视化表示就如同下面这些内容。<br>其实,每一行后面都跟着\r\n,不过这是换行符,所以在屏幕上展现出来就是一行一行的数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>了解了这些以后,我们就可以继续进行了  </p>
<p>既然一切都是消息,那么当我们发送一个http请求的时候,Tomcat最开始接收到的也是一串像是上面这种的字符串,java中接收消息用的就是socket,Tomcat也不例外。  </p>
<p>所以我在文章最开始的时候说到：“Tomcat实质就是对socket的深度封装”</p>
<p>在获取到socket套接字以后，Tomcat开始解析<br>根据传入内容标明协议的不同,按照在代码中定义好的各种协议模板来解析这个字符串。<br>解析完成后封装到Request和Response中交给Servlet执行用户自定义的业务代码,最后再由socket发送响应,这就是Tomcat大致的流程</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Tomcat的各个组件也是有生命周期的,这个生命周期由一种设计模式(状态机)来控制,下面让我们了解一下</p>
<p>首先要介绍的是LifecycleMBeanBase类,下面是这个类的类图<br><img src="//ryanstian.github.io/2019/08/14/Tomcat源码笔记/LifecycleMBeanBase%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="如果图片失效,请邮件联系作者补图"></p>
<p>我们从Lifecycle接口开始了解,Lifecycle定义了一个状态机,下面是Lifecycle的原注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*            start()</span><br><span class="line">*  -----------------------------</span><br><span class="line">*  |                           |</span><br><span class="line">*  | init()                    |</span><br><span class="line">* NEW -»-- INITIALIZING        |</span><br><span class="line">* | |           |              |     ------------------«-----------------------</span><br><span class="line">* | |           |auto          |     |                                        |</span><br><span class="line">* | |          \|/    start() \|/   \|/     auto          auto         stop() |</span><br><span class="line">* | |      INITIALIZED --»-- STARTING_PREP --»- STARTING --»- STARTED --»---  |</span><br><span class="line">* | |         |                                                            |  |</span><br><span class="line">* | |destroy()|                                                            |  |</span><br><span class="line">* | --»-----«--    ------------------------«--------------------------------  ^</span><br><span class="line">* |     |          |                                                          |</span><br><span class="line">* |     |         \|/          auto                 auto              start() |</span><br><span class="line">* |     |     STOPPING_PREP ----»---- STOPPING ------»----- STOPPED -----»-----</span><br><span class="line">* |    \|/                               ^                     |  ^</span><br><span class="line">* |     |               stop()           |                     |  |</span><br><span class="line">* |     |       --------------------------                     |  |</span><br><span class="line">* |     |       |                                              |  |</span><br><span class="line">* |     |       |    destroy()                       destroy() |  |</span><br><span class="line">* |     |    FAILED ----»------ DESTROYING ---«-----------------  |</span><br><span class="line">* |     |                        ^     |                          |</span><br><span class="line">* |     |     destroy()          |     |auto                      |</span><br><span class="line">* |     --------»-----------------    \|/                         |</span><br><span class="line">* |                                 DESTROYED                     |</span><br><span class="line">* |                                                               |</span><br><span class="line">* |                            stop()                             |</span><br><span class="line">* ----»-----------------------------»------------------------------</span><br></pre></td></tr></table></figure>

<p>我们可以看到,这是一种状态机设计模式。规定了组件生命周期的状态转换,可以方便的进行组件生命周期的管理。  </p>
<p>从下图我们可以看到,从Server开始几乎每一个组件间接继承/实现了该状态机<br><img src="//ryanstian.github.io/2019/08/14/Tomcat源码笔记/Lifecycle%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8.png" alt="如果图片失效,请邮件联系作者补图"></p>
<p>接下来让我们看LifecycleBase,这是一个抽象类,实现了fireLifecycleEvent,init,start…等方法</p>
<p>fireLifecycleEvent的设计其实是根据观察者模式</p>
<p>init,start等方法仅仅是用来控制其生命周期的,每个方法例如init,在内部还会调用initInternal(),Tomcat的很多组件的业务代码全部都在xxxInternal()中,由子类负责实现</p>
<p>LifecycleMBeanBase则对LifecycleBase进行了进一步的实现,我们从它的图中可以看到<br><img src="//ryanstian.github.io/2019/08/14/Tomcat源码笔记/LifecycleMBeanBase%E7%B1%BB%E5%9B%BE.png" alt="如果图片失效,请邮件联系作者补图"></p>
<p>其中最关键的是initInternal()和destroyInternal()。<br>主要实现了委托Register类来将子类(类如StandardServer等)注册到bean容器中。</p>
<p>如果在看源码过程中大家对ManagedBean或者MBeanServer抱有疑惑,可以先去学习一下JMX规范再回来看容器部分代码,不过即使跳过容器部分,也不影响接下来的部分</p>
<h2 id="Tomcat初始化流程-仅需有个印象即可"><a href="#Tomcat初始化流程-仅需有个印象即可" class="headerlink" title="Tomcat初始化流程(仅需有个印象即可)"></a>Tomcat初始化流程(仅需有个印象即可)</h2><p>Tomcat工作主要有几个流程:</p>
<ul>
<li>init(负责new各级对象,组件依赖关系,加载配置文件)</li>
<li>start(这一步完成时可以正常接收请求开始处理)</li>
<li>处理消息</li>
<li>结束</li>
</ul>
<p>首先放一张tomcat init的流程图(简化版)<br><img src="//ryanstian.github.io/2019/08/14/Tomcat源码笔记/tomcat%E6%97%B6%E5%BA%8F%E5%9B%BEinit.png" alt="如果图片失效,请邮件联系作者补图"></p>
<ul>
<li>Bootstrap:是入口,例如命令行输入service tomcat start等操作时,便是由这个类来解析,这个类均通过反射操作来调用Catalina</li>
<li>Catalina:提供了操控Tomcat启停等行为的方法</li>
<li>LifecycleBase:状态机设计模式,我们后文会提及,StandardServer等大部分组件都会实现该状态机</li>
<li>StandardServer:顶级容器,一个Tomcat对应唯一一个Server,负责管理多个service的启停等行为</li>
<li>StandardService:可以完整执行功能的最小单元容器(如果不明白可以先继续看)<br>下面是一个server.xml文件去掉注释后的内容。根据xml我们可以清楚的看到其构建逻辑<br>Server包含Service,Service包含Connector和Engine,Engine包含host<br>假如我们现在面临一个问题,有两个同名的项目需要发布或者希望不同项目部署在不同的端口,那么我们就可以在后面新增一个service</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>ScheduledThreadPoolExecutor:线程池,后面我在讲述线程模型的时候会讲到</p>
</li>
<li><p>Container容器模块,呈现包含关系,之间以责任链形式调用,这里注意一点,虽然方法名是invoke,但实际上并不是通过反射来调用,类似的在tomcat中也有很多继承了Runnable但是有些模块用不到start而是使用run的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Engine&#123;</span><br><span class="line">    Host&#123;</span><br><span class="line">      Context&#123;</span><br><span class="line">        Wrapper</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Endpoint:核心部分,后面讲线程模型我会提到</p>
</li>
<li><p>Tomcat的start流程其实跟init流程类似,在宏观上几乎没有改动,因此省略</p>
</li>
</ul>
<h2 id="Tomcat接收消息流程"><a href="#Tomcat接收消息流程" class="headerlink" title="Tomcat接收消息流程"></a>Tomcat接收消息流程</h2><p>这里我认为一张图足以<br><img src="//ryanstian.github.io/2019/08/14/Tomcat源码笔记/tomcatNIO%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="如果图片失效,请邮件联系作者补图"></p>
<h2 id="一些关键的节点"><a href="#一些关键的节点" class="headerlink" title="一些关键的节点"></a>一些关键的节点</h2><p>这里将提供一些消息在Tomcat中传递的关键节点,可以帮助大家通过全局搜索快速定位到源码</p>
<ul>
<li>init时:<br>这里有人会疑惑类的初始化和注入依赖在哪里,答案是digester.parse<br>这种感觉就像是我们写springMVC时配置的xml一样,在这里xml就是server.xml。digester会根据这个xml来解析并注入依赖</li>
<li>NIO接收消息时:<br>关键类Acceptor。其run方法是核心,endpoint.setSocketOptions是转折点。随后一系列操作将accept到的封装为PollerEvent加入队列</li>
<li>关键类Poller：<br>从队列取处PollerEvent注册到socketChannel的Selector选择器中,并且负责轮询读写事件,将其封装后扔到线程池中</li>
<li>关键类SocketProcessor：<br>被上文封装的Runnable,负责接下来的读取解析处理返回操作</li>
<li>关键类Http11Processor：<br>inputBuffer.parseRequestLine获取并解析请求,如果是文件传输类型,那么不会解析消息体,如果是表格那种文本的,就会一起读取出来</li>
<li>具体从socket读取消息的地方:<br>Http11InputBuffer类的socketWrapper.read。<br>NioSocketWrapper类的nRead = fillReadBuffer(block, to)</li>
<li>关键类Http11Processor：<br>inputBuffer.parseHeaders将读取出的消息解析为消息头</li>
</ul>
<h2 id="这里我们讲Tomcat线程模型"><a href="#这里我们讲Tomcat线程模型" class="headerlink" title="这里我们讲Tomcat线程模型"></a>这里我们讲Tomcat线程模型</h2><p>TomcatNIO的线程模型其实非常简单,简单到什么程度?让我们看图<br><img src="//ryanstian.github.io/2019/08/14/Tomcat源码笔记/TomcatNIO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="如果图片失效,请邮件联系作者补图"></p>
<p>甚至于io操作和业务操作在同一根线程上进行,没有经过分离,poller的职责仅仅是检测事件,并不负责io操作,<br><font color="red">注意这仅仅是NIO模式,不包括另外两种NIO2和APR模式</font></p>
<p>我们看server.xml配置文档的时候可以看到允许我们设置一些参数,这里之前tomcatNIO接收请求逻辑图已经描述过,不再赘述。</p>
<p>至于Poller,你在看旧文章时有人会说允许最大值不超过2个。没错,在之前的版本是这样,但是在9.0,我们看到注释文档中有句话,在NIO下Poller被改为仅有一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update&gt;</span><br><span class="line">    Remove &lt;code&gt;pollerThreadCount&lt;/code&gt; Connector attribute for NIO,</span><br><span class="line">    one poller thread is sufficient. (remm)</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p>通过这些,我们可以分析到<br>Tomcat NIO模式下,是通过粗暴的增加线程来处理请求。<br>如果同时请求数过多,会被ServerSocketChannel阻拦掉<br>如果交给线程池的read达到线程池上限,那么就会加入队列中进行排队<br>这也就是Tomcat无法承受大量并发的原因所在</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>简记20210818234900</title>
    <url>/2021/08/18/%E7%AE%80%E8%AE%B020210818234900/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="一、看清屎山"><a href="#一、看清屎山" class="headerlink" title="一、看清屎山"></a>一、看清屎山</h1><p>校招生踏入公司，普遍第一项工作是熟悉业务，熟悉架构，熟悉代码。</p>
<p>这个流程本没有错，那么坑在哪？在于习惯。新人就像海绵，看到什么，便会学什么</p>
<p>而大家都知道。业务代码，由于历史包袱，或是人力紧张，又或者是种种不可抗力因素，本身就是屎山中混杂金子。</p>
<p>有的新人懂得多，或者习惯求索原因，可以从中看出设计中不合理的地方  </p>
<p>而有些更为初学者的新人，则会在学习过程中全都当知识学进去，导致后续到自己设计时把代码补丁当成设计原则。不得不说，这简直是灾难</p>
<p>在这里，我不得不提醒大家们两点</p>
<ul>
<li>相信推理胜过相信别人。</li>
<li>防火防盗，防同事吹逼</li>
</ul>
<p>这两句话具体怎么理解，我给大家举个例子就懂了</p>
<ul>
<li>曾经有个team轰轰烈烈推广他们的工具，看完他们功能介绍PPT和文档，内部讨论一波，感觉这工具很可以。<br>后来找他们team开始深入沟通。然而这一沟通，就发现了大坑，大致过程如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一顿背景介绍过后。。。</span><br><span class="line"></span><br><span class="line">我方team：能给我们详细讲下你们这个架构是咋玩的吗？</span><br><span class="line">对方team：巴拉巴拉。。。</span><br><span class="line"></span><br><span class="line">我方team：诶，那这个xxx问题你们是怎么解决的？</span><br><span class="line">对方team：噢，我们是这个场景，巴拉巴拉。</span><br><span class="line"></span><br><span class="line">我方team：有点问题，那如果这个地方xxx你们怎么解决？</span><br><span class="line">对方team：额，这个问题我们不会遇到</span><br><span class="line"></span><br><span class="line">沉默ing。。。</span><br><span class="line"></span><br><span class="line">我方team：感谢感谢，了解了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>仔细品，我相信可以品出来很多东西。  </p>
<p>很多情况下，我们的项目只适合于某些特定的场景，又或是迫于KPI，将半成品伪装成精品。</p>
<p>不是所有人都会承认自己项目存在缺陷，若是隐藏起缺陷，而你又被精美PPT忽悠了。那么恭喜，你又会隐藏起自己项目缺陷再次背刺下一位幸运儿。  </p>
<p>在工作中，最重要的，是相信自己的思考。伪装再好的缺陷，也能被找到蛛丝马迹。隐藏再深的金子，当思绪扫过，也能透出点点微光</p>
<p>总之一句话：屎山中淘金，莫把屎当宝</p>
]]></content>
      <categories>
        <category>简记</category>
      </categories>
  </entry>
  <entry>
    <title>简记20210818234800</title>
    <url>/2021/08/18/%E7%AE%80%E8%AE%B020210818234800/</url>
    <content><![CDATA[<a id="more"></a>
<p>时光荏苒,不知不觉已然进入社会一个春秋  </p>
<p>博客的事情停滞许久。究其因，怠惰自然居首位，然还有一点便是提笔难下</p>
<p>一年前的自己，觉得自己懂得很多。一年后的自己，知道<br>自己才不过是刚刚入门。不得不说，学到的越多，越会发现自己的无知。</p>
<p>这一年里，求知，热情，激动，无奈，彷徨，最终归于平静。接下来我将逐渐记录这些岁月，记录这有趣的生活，以及一路上所学所看所感。</p>
]]></content>
      <categories>
        <category>简记</category>
      </categories>
  </entry>
  <entry>
    <title>几种线程模型</title>
    <url>/2019/08/17/%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>我们来谈一谈java中常见的几种IO线程模型</p>
<a id="more"></a>

<h2 id="同步阻塞-bio"><a href="#同步阻塞-bio" class="headerlink" title="同步阻塞(bio)"></a>同步阻塞(bio)</h2><p>在read时需要无限等待直到消息到达,就是阻塞,同步则指的是每一步都需要等待上一步完成然后被调用<br><img src="//ryanstian.github.io/2019/08/17/几种线程模型/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9Eio.png" alt="如果图片失效,请邮件联系作者补图"></p>
<h2 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞()"></a>同步非阻塞()</h2><p>同步阻塞和同步非阻塞的区别就在于,在read时无论是否有数据,立刻返回。</p>
<p>那么或许有人会问了,这样有什么意义,还不是需要自己写while循环包裹来促使其不断访问直到数据到达？</p>
<p>其实针对这一点,如果一个线程进入了阻塞状态,也就意味着这个线程无法用来做其他事情。</p>
<p>如果我们是非阻塞的情况下,我们发现read数据未到达,可以先允许该线程去做其他工作,过一会再来read一次检测下消息是否到达,同时我们也可以通过标记位来控制其后续行为<br><img src="//ryanstian.github.io/2019/08/17/几种线程模型/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9Eio.png" alt="如果图片失效,请邮件联系作者补图"></p>
<h2 id="io多路复用-nio"><a href="#io多路复用-nio" class="headerlink" title="io多路复用(nio)"></a>io多路复用(nio)</h2><p>其实nio也被算作同步非阻塞,不过我们不必拘泥于这些分类,在发展中,是先有的模型,后来才被分类,所以很多情况下分类是模棱两可的。</p>
<p>io多路复用跟之前说的同步非阻塞有点关系,io多路复用的read也是非阻塞的,跟之前的最大区别在于,他采用了Selector选择器负责监听每一个socket的各种行为,当该行为被激活的时候,通知后续线程去处理。</p>
<p>我们可以想象,此时有巨量的socket链接进来,我们需要为每一个socket创建一个线程来read</p>
<p>即使是使用线程池减少了创建线程的消耗,那么大量的线程也依旧会在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while()&#123;</span><br><span class="line">    //read</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上浪费掉,此时我们就需要一个方案来解放这些线程无意义的循环read</p>
<p>一个管理者,来管理所有的Socket,这也就诞生了Selector选择器,由Selector负责检测是否有accept,read,write行为,并且通知其他线程来处理,这样我们可以节约大量线程,配合线程池我们就可以用有限的资源处理大量的连接</p>
<p><font color="red">假设我们将流程分类为,io监听和io接收,业务处理三部分,那么nio的核心就是在于将io监听给提取出来单独管理</font><br><img src="//ryanstian.github.io/2019/08/17/几种线程模型/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="如果图片失效,请邮件联系作者补图"></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>说到异步,阻塞与非阻塞的界限更为模糊。</p>
<p>下面让我们来看一段代码,这段代码并不是异步,他只是一个回调雏形,后面我会谈到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(CallBack callBack)</span></span>&#123;</span><br><span class="line">        <span class="comment">//业务代码省略...</span></span><br><span class="line">        callBack.callback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        main.work(<span class="keyword">new</span> CallBack() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你对代理模式比较熟悉,那么这里你肯定会产生疑问:这不就是代理模式么?</p>
<p>嗯,没错,这个东西在我眼里就是代理模式,这里我们传入了自定义的代码,这就是回调的雏形</p>
<p>你肯定会问,这有什么用?还不如直接在一个方法里从头到尾写下来。</p>
<p>这是因为我们还没有引入其他的模型,假设我们引入多线程,那么我们的代码就成了这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(CallBack callBack)</span></span>&#123;</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        callBack.callback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                main.work(<span class="keyword">new</span> CallBack() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对比,我们发现,引入了线程的概念后,他的意义就完全改变,变成了一种近似异步(不必在乎这些概念,你重点关注的应该是是否对于性能有真正的提升)的实现。</p>
<p>假设我们面对这样一个场景(此处我们先以非阻塞为例,否则引入自变量过的多不宜于理解)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、两个socket AB互相长期通信</span><br><span class="line">2、且每次通信在业务上(我们先将流程简单的分为为io,业务处理两部分)所需要耗费的时间是不确定的</span><br><span class="line">3、假若说我们采用同步的方式。</span><br><span class="line">每一次A发往B,因B只有一根线程。需要 读io-&gt;业务操作-&gt;写io 后才可继续处理A的后续请求。</span><br></pre></td></tr></table></figure>

<p>而现在,我们将双方模型改为异步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、A只要有请求就向B发送,无需等待B响应</span><br><span class="line">2、当B读取完消息后,将消息封装为一个任务,递交给线程池执行</span><br><span class="line">并立刻返回A一条消息表示自己已经接收到了请求。</span><br><span class="line"></span><br><span class="line">//你可能会问A一直在发送消息,B怎么知道A是发送到一个请求还是两个请求,这一点可以去了解粘包拆包的问题</span><br><span class="line">//执行完毕后会将执行回调函数来决定接下来的操作,由于任务耗时的不确定性,如果返回消息的话,消息的先后顺序也是不确定的,所以A在请求时需要附带消息的序列号</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title="//"></a>//</h3><p>到这里仿佛一切豁然开朗</p>
<p>但是,我刚才做的将同步改为异步的操作,真的提高了性能么？</p>
<p>假设我线程池只设置一根线程,那么性能跟io和业务在同一根线程有区别么？<br>这真的是异步带来的效益,还是仅仅是多线程带来的福利?</p>
<p>我只不过是让A提前知道了,B已经接收到了来自A的消息,但是实际如果线程池只有一根线程的话,业务处理时间是不会改变的。  </p>
<p>那么异步的意义何在，仅仅是为了利用起多线程并发处理业务这个效果么?</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><p>异步确实起到了利用多线程的作用  </p>
<p>这里的异步我们要明确,异步并非是一个确切的概念,而是一个抽象宏观的概念,是针对于观察点而不断变化的</p>
<p>例如在当前这个场景中。如果A只有当收到B的处理结果才会继续发送,那么B的异步还算是真正的异步吗?  </p>
<p>我们当然可以说B是异步的。但是对于整体来说,他又是同步的,B在此时的是无法体现其性能优势的。</p>
<p>假如说在这个基础上,有许许多多的A连接同一个B向其发送消息。<br>此时B针对每一个连接起一个io线程(这里当然可以用Selector选择器配合io线程池)<br>接到消息后扔到线程池(即使线程池只有一根线程,但是由于io是并发的,省去了io时间)去处理<br>这时候B又能体现他的性能优势了</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h3><p>那么接下来我们抛开异步同步阻塞非阻塞这个问题,从性能方面总结一下,之前我们提到的线程模型,变化繁多,那么他们为了性能所做的改变都有什么共同点呢?</p>
<p><font color="red">将职责精细划分,对于每一部分职责分别进行深度优化,使得每一部分职责成为一个组件,各组件之间相互通信,以避免某一组件因为另一组件的原因而造成无意义的等待</font></p>
<p>在并发量低的环境下,由于我们机器可以开足够的线程来处理消息,即使义务处理因为io产生了等待,其他的消息也可以选择其他线程去处理。  </p>
<p>而当并发量增高,此时如果我们线程随之增高的话,会产生大量的线程上下文切换开销,所以我们不得不把控线程的数目,转而通过技巧来充分利用起每一条线程(例如线程池,组件功能划分等方式)  </p>
<p>这也就是这些线程模型存在并逐渐演化的原因</p>
<p>PS：不得不说协程机制确实给我们带来了便捷。那是那仅仅是便捷，而不是万金油，具体还要结合业务场景去分析。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>简记20210829224600</title>
    <url>/2021/08/29/%E7%AE%80%E8%AE%B020210829224600/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="四、语言真的那么重要吗？-C-java-go-py"><a href="#四、语言真的那么重要吗？-C-java-go-py" class="headerlink" title="四、语言真的那么重要吗？(C+,java,go,py)"></a>四、语言真的那么重要吗？(C+,java,go,py)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一位小伙在论坛大喊：Java天下第一!</span><br><span class="line">随后，一场键盘战争开始了</span><br></pre></td></tr></table></figure>

<p>我曾看到过数不清的段子，大致含义相同，都是争论自己使用的语言是最好的语言。  </p>
<p>起初我认为语言非常重要，把他当作未来深入前进的方向，由此会将语言特性示若圣经，潜意识里排斥其他语言的工作。<br>最有代表性的事件，就是在投递工作简历时，会特地寻找Java工程师的JD。遇到其他语言，则会犹豫再三</p>
<p>后来一次偶然的机会，接触到golang相关的工作。golang对我来说是一种全新的语言，我对它的特性毫不了解。<br>这得我在工作时无暇顾及其特性把问题解决方案，用我手中的工具去落地实践。  </p>
<p>在一阵忙碌后，轻松下来的自己复盘之前的工作。偶然间发现，即时不用语言特性，我也依旧能做到任何事情？？？<br>//TODO 没灵感，搁置</p>
]]></content>
      <categories>
        <category>简记</category>
      </categories>
  </entry>
  <entry>
    <title>简记20210822191000</title>
    <url>/2021/08/22/%E7%AE%80%E8%AE%B020210822191000/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="三、能RUN就行"><a href="#三、能RUN就行" class="headerlink" title="三、能RUN就行"></a>三、能RUN就行</h1><p>这是一则真实的段子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有人在网上发帖提问</span><br><span class="line">提问者：自己写的代码太难看了怎么办？</span><br><span class="line">路人A：能run吗？</span><br><span class="line">提问者：我run还是代码run？</span><br><span class="line">路人B：有一个能run就行</span><br></pre></td></tr></table></figure>

<p>不得不说，真的是人间真实。接下来我们聊一聊，该如何做到“能RUN就行”。</p>
<p>记得在我刚刚实习的时候，一段简单的代码写了改，改了写，最后推到重构。写完了，自己看着代码非常愉悦，但却又因几天后的一个紧急需求，不得不改成他最初的样子。</p>
<p>经过了一年的修修补补，我理解了什么叫“能RUN就行”。当然，这仅针对业务代码而言，因为业务需要紧跟市场脚步，需要的是最短时间代码能RUN，不宕机，而且后面还改的动，能坚持到下次被重构，这就是一份代码的使命。</p>
<p>之前我曾看到有人这么评价业务架构师（注意是业务）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序员的作用是堆粪。架构师的作用是搭架子。</span><br><span class="line">屎山堆高，自己就塌了。有架子在，尽管臭，却能用</span><br></pre></td></tr></table></figure>

<p>实在是很形象了。</p>
<p>平时我们设计方案也是如此，方案不是越复杂越好，难的不是把方案完成，而是把复杂方案简单化。</p>
<p>比如说才几万条数据，没啥热点，未来2年也不会增长到接近几百万，这时候来个分库分表，实属闲的。等到后面做编码的时候，这分库分表的编码复杂度反而得不偿失。</p>
<p>又比如各个表都是按相同维度进行分表，你经过一系列的分析，算出来这个表该分表10张，另一个15张，再来一个50张。<br>当你接到个批量跨表数据分析工作，麻烦就来了。</p>
<ul>
<li>扫全表，压力大。</li>
<li>扫单表，你就只能根据分表id计算最大公倍数，再来hash到对应分表  </li>
</ul>
<p>或许这里有人会反驳，数据分析这种东西，不都是用数仓么？<br>但是这仅是个例子，不是所有的公司都支撑的起数仓，也不是所有的数据分析业务都需要放到数仓去跑</p>
<p>我曾经也是追逐“完美”的人，但在追逐过程中我学到：<br>世上并没有真正的完美，但从一种角度，它是完美的。但换一种角度，丑陋不堪。最终美好的仅是综合情况下的取舍。</p>
<p>话说回来，一切都要讲究变通。  </p>
<p>曾经我见过有人为了尽量少的采用中间件，用mysql来控制并发场景下的库存，还设计预分配库存量等机制。<br>显然，运行了一段时间后QPS上来，程序RUN实在不动，人RUN了。<br>我们只能含泪接手代码，花费大力气把他的设计废掉改用redis</p>
<p>总之，不要为了复杂而复杂，也不要为了简化而简化，凡事讲究有度。</p>
]]></content>
      <categories>
        <category>简记</category>
      </categories>
  </entry>
  <entry>
    <title>简记20210822174300</title>
    <url>/2021/08/22/%E7%AE%80%E8%AE%B020210822174300/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="二、跳出固化思维"><a href="#二、跳出固化思维" class="headerlink" title="二、跳出固化思维"></a>二、跳出固化思维</h1><p>经过第一阶段在摸爬滚打，相信已经有了些许积累，学到了很多。  </p>
<p>这时，我相信你至少已经知道了。什么时候该用分库分表，什么时候该用redis，什么时候该用kafka等等一系列的简单应用。</p>
<p>大致了解原理以及会用是一方面，精通又是另一方面。大部分工作的人，也仅仅是了解原理及停留在会用的阶段。当然这并不会妨碍我们用它们来设计我们的程序。</p>
<p>好了，让我们回归正题。</p>
<p>当你进行一项程序，我希望你忘记自己学过的各种中间件，学过的各种语言等等。</p>
<p>此时便可以从程序本质出发，从需求开始，一点点分析你需要哪些特性来组装出你的程序，然后去寻找适合的技能，而非从自己所有的技能中做排除法。</p>
<p>等我们把所需的特性一一列出以后。才是需要结合团队掌握的技能，以及底层支持等各种情况，来进行综合考虑的情况。</p>
<p>这里我会举几个例子，当然受限于保密等原因，无法说的太过详细。但已经足以辅助理解。</p>
<p>examle1：<br>刚入职场时曾经遇到了这样一个问题：  </p>
<p>我需要定时对一系列的信息进行处理，根据来源方不通进行不同的处理规则，处理规则依托于各渠道方强相关。  </p>
<p>并且在我程序运行过程中，还会源源不断的增加新来源方，以及改变旧有渠道处理方式。  </p>
<p>在我处理完数据后，会对几方数据进行比对，然后根据渠道组合不同，定制不同的清理流程  </p>
<p>solution1-1：<br>此时，其实总的来说就两个问题。</p>
<ul>
<li>1.通用性 VS 定制化</li>
<li>2.流程复杂性</li>
</ul>
<p>这一阶段，我所掌握的知识相当有限。在我的认知范围内，我是这样思考的：</p>
<ul>
<li>1.由于各个业务流程过于复杂，如果单独为每个业务定制，那么后期维护复杂度会把我拖垮。于是我需要在所有业务中抽象出一个共性模型。在通用的基础上，用不同的策略（策略模式）去处理定制化问题</li>
<li>2.因为流程复杂多变，我对需求进行了分析，去google上参考业界通用流程，在复杂流程中关键步骤抽离出来，考虑各自成为服务，各服务无状态且可横向扩展。<br>让数据通过中间件为中转，流转于各个服务中，通过控制不同数据在服务中的流转顺序，以此来解决流程复杂性问题（后来考虑到维护成本，被要求压缩在一个服务里，通过方法调用来分割了）</li>
<li>3.但还有一个问题没有解决，各业务的定制化逻辑。这里比较困难的一点为，逻辑与渠道方高度耦合，即我们需要完全掌握业务方逻辑才可以定制出处理规则，这是相当困难的。<br>我曾考虑过采用动态加载插件的形式，让业务将他们的规则封装在一个插件中，交由我们在程序中热拔插。后来考虑到这其中的不可控性便被放弃了（例如业务方写的规则需要在我们服务上跑，很容易失控）。<br>最终，基于各种压力，我们选择将一小部分及其特殊的逻辑让各渠道方预处理（或是我们替其进行预处理），然后走入通用逻辑。</li>
</ul>
<p>在这一阶段，我的知识储备中并没有dag调度，大数据处理等概念。但是通过对业务的分析，已经衍生出雏形。</p>
<p>这也是我为什么强调，忘记自己的知识储备，从需求来分析需要什么，而不是你会什么。</p>
<p>———–扩展———–  </p>
<p>solution1-2：<br>后来接触了DAG调度平台，可以发现。其中的流程复杂性，便是dag中的流程控制。  </p>
<p>本质上与我们先前拆分为多个微服务进行处理并没有区别，只不过dag平台提供了更为巧妙的调度方式，以及更为简洁的编码。</p>
<p>让我们在思考一下，我们拥有了流程调度能力，并且我们的业务已经发展的比较复杂，各种渠道的定制化流程复杂交错。  </p>
<p>先前我们制定的通用化模型，应付现在的场景非常吃力。任何一个渠道的改动，均需们发版来更新，会影响到所有渠道的处理。而且每次改动均需考虑兼容性问题</p>
<p>此时，我们该如何协调定制化与通用化的矛盾呢？（该答案并未亲自实践）</p>
<p>答案是，反过来，在定制化的基础上做通用。  </p>
<p>先前我已经提到，我们是定时任务，也就意味着，当我们有能力通过调度平台将各渠道拆分后，我们并不需要程序一直在run。可以在需要被调度时，通过调度平台启动对应渠道的处理程序。</p>
<p>此时我们的编程思想要转换一下，我们的代码并不需要控制整个流程，而是像一个个插件一样被使用，我们仅需维护一个插件库。  </p>
<p>当某个渠道紧急需求过来时，我们可以在插件库中找到该渠道对应的通用模型，复制出来一份，对其进行紧急定制化。在后期维护时，我们尝试将定制化功能抽离成通用功能，再添加回插件库。</p>
<p>调度平台通过在我们插件库中选择合适的插件，编排出各个渠道的任务</p>
<p>solution1-3：<br>随着后来的学习，我们接触了大数据。了解到对于数据的处理，原来是已经有现成的轮子，不需要我们自己去费尽心思，进行横向扩展来增加吞吐。</p>
<p>那么回过头来，我们再思考一下。随着时间的增长，我们的程序资源占用逐渐出现了问题。</p>
<p>在高峰期，我们的任务全堆在一起，CPU内存带宽磁盘IO等非常吃紧，并且有宕机趋势。然而在非任务期间，所有资源全部闲置。那么我们该如何解决这个问题？</p>
<p>这里就不得不提到大数据平台了。之前提到，我们的数据流其实是在各个服务中流转的，这无疑增大了我们的负担。但如果，我们的程序仅仅负责命令流呢？</p>
<p>通过将数据加载到大数据平台，我们的插件被调度平台控制，向大数据平台提交命令，处理任务。整个流程中，我们的流程控制的机器几乎不会接触到任何数据流，命令的发出几乎不会消耗资源。</p>
<p>这时候你或许会问，大数据平台难道不需要消耗资源处理数据吗？</p>
<p>当然时需要的，只不过你是跟其他团队在共享资源。你的任务空闲时，这些资源会被其他团队使用。</p>
<p>当然类似的，你也可以做到与k8s团队合作，做到动态删减容器节点，在满足你使用的情况下节约资源</p>
]]></content>
      <categories>
        <category>简记</category>
      </categories>
  </entry>
</search>
